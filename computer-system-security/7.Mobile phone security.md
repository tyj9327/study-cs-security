**Side channel**



1. **정의** 

유저와 서버와의 전송과정을 공격하는 것이 아니라, 유저 서버 각각에서 발생되는 부가적인 정보를 바탕으로 정보를 알아내는 방식의 해킹을 의미한다. 

40년대에 최초로 발견됐는데, 타이핑 할때 방출되는 RF 주파수를 바탕으로 어떤 character가 타이핑 되는지를 추론할 수 있었다.

다양한 방식이 존재하는데, 예를들면 전력 사용량이나 소리 같은 것이 있을 수 있다. 다양한 인풋을 보내 이에 반응하는 시간을 통해서도 여러가지 정보를 얻을 수 있다. 



2. **RSA 암호화 방식 - 소인수 분해를 활용한 비대칭키.**

RSA의 핵심은 지수화다. 암호화와 해독과정에서 지수를 곱하게 돼 매우 큰 값이 계산되게 된다. 이로 인해 많은 계산이 소요되는데 이를 해결하기 위해 계산을 간단하게 하는 방법을 사용한다. 

이 과정에서 각각의 테이블에 메모리가 접근해서 값을 가져오게 되는데 이 각각의 값들이 메모리에 들어갔다가 나오는 시간을 바탕으로  side channel 공격이 가능할 수 있음. 예를들어 특정 값이 매우 크다면 계산이 오래걸리게 될 것 이고, 이를 바탕으로 특정 값을 계산함에 있어 큰 값이 사용되었음을 알 수 있게 된다.



**Mobile phone security**



 안드로이드는 유닉스와 웹에서의 보안과 다른 양상을 띄는데 그 이유는 안드로이드 설계 초기부터 보안적 관점을 갖고 개발됐기 때문이다. 안드로이드 시스템은 여러개의 모듈의 합으로 구성되어 각 모듈에 대한 권한을 어플리케이션에서 가져야만 사용할 수 있게 설계되었다. 

 안드로이드 앱에서 고려해야할 보안은 접근되지 말아야 할 혹은 주의깊게 다뤄져야 할 정보 혹은 자원들을 잠제적으로 위험할 수 있는 앱들로부터 어떻게 보호할 것인가? 의 관점에서 이해해볼 수 있다. 이러한 관점에서 안드로이드는 앱들을 독립시키고 각각에 독립된 권한을 부여(승인) 하는 방식으로 설계되었다.



**Android 이해**

안드로이드 애플리케이션의 컴포넌트는 크게 4가지로 구분된다.



Activity : 유저인터페이스와 관련된 컴포넌트. 유저에게 인풋을 받고 앱을 구동시키는 대부분의 작업들이 이뤄지는 모듈임

Service: 백그라운드에서 실행되는 컴포넌트. GPS를 통해 위치를 전송하는 등의 작업을 함

Content Provider: SQL같은 데이터 베이스 혹은 테이블

Broadcast Receiver: 다른 파트의 시스템으로부터 메시지를 받는데 쓰인다. 



Manifest : 이 애플리케이션이 할 수 있는 권한들을 담은 xml 파일 ex)인터넷 사용, 파일 시스템 접근 권한 등



Intent : 다른 앱에 보내는 구조화된 메시지. Component(intent를 보낼 앱), Action(취할 행동), Data/MIME type (함께 보낼 데이터)



위의 핵심 개념들을 바탕으로 안드로이드가 구동되는 형태에 대해 설명하면, 



APP1과 APP2 는 각각이 activity, service, content provider, broadcast receiver를 갖고 있다. 이 각각은 리눅스 커널 위에서 돌아간다. APP1, APP2는 각각이 manifest를 통해 정의된 권한을 갖고 있다. 



APP1       APP2        RM(reference monitor - 각 앱들의 위치를 기억하는 곳)

--------------

Linux kernel



APP1에서 APP2로 intent를 보낼때는 RM을 통해 intent를 보내게 된다.



이때 app들은 java기반으로 구동된다. 



**Android 설계 이유**



안드로이드는 왜 이렇게 다른 컴퓨터 프로그램이나, 웹앱과 다르게 이런 방식으로 네가지 컴포넌트와 Intent, manifest들로 설계되었을까?  분명 데스크톱 앱이나 웹 앱도 사용가능했다. 이 둘을 비교해보면,



Desktop app 

- 설치가 어려움
- 앱들간의 isolation이 없음
- 앱간의 sharing이 쉬움



Web app

- 설치가 쉬움
- Isolation이 되어 있음
- 디바이스 전용 API가 제공되지 않는다.
- 앱 간의 sharing이 어렵다.
- 오프라인 상태에서의 제어가 어려움(현재는 해결됨)



결국 두 플랫폼에서 모바일 환경에서 원하는 제어(isolation과 sharing이 모두 가능한 구조)가 어려웠기에, 리눅스 커널 기반으로 하되 APP간에 환경이 고립될 수 있게 만들게 되었다고 이해해볼 수 있다. 



JAVA를 택한 이유는 

-  상대적으로 쉽게 개발할 수 있는 언어이고 보안에 관해 신경쓸 것이 적다.

- 성능상으로 jre나 머신 위에서 구동되기 때문에 전력 소모에 불리할 수 있지만, 디바이스나 cpu종류와 상관 없이 빌드 가능하다는 점에서 유리해 선택되었을 것이다.





**안드로이드의 manifest를 이용하는 이유**

- 리소스(음성, 카메라, 파일 시스템)의 할당을 제어하기 쉽다.
- 유저에게 앱이 필요로 하는 권한을 선택하게 해 이상한 동작이 있을 경우 유저가 막게 할 수 있다.



manifest에서 할당하는 label(권한들)에는 normal, dangerous, signature로 나뉘어져 있다. 

- normal타입은 유저에게 권한요구에 대한 허락을 받지 않아도 된다. 중요한 권한은 아니어서 유저에 의해 체크될 필요는 없지만, 이를 명시함으로써 개발자가 앱이 어떤 기능에 접근하고 있는지를 알 수 있게 된다.
- dangerous 타입은 유저의 권한을 필요로 하는 권한이다.
- signature 타입은 동일한 서명을 가진 어플리케이션의 경우 사용자의 명시적인 승인 없이 다른 어플리케이션에서 획득한 권한을 자동으로 권한을 부여할 수 있는 권한을 의미한다.



**안드로이드의 구조에서 특장점**



안드로이드의 특이한 점은 개발자가 직접 보안 규정을 정의하고 사용할 수 있다는 점이다. 그리고 이 보안 규정을 바탕으로 앱이 접근할 수 있는 권한에 대한 감시자(RM과 프레임워크)가 있어 모든 앱들의 코드를 직접 보지 않아도 manifest파일에 대한 검사만으로 이 앱이 갖게 될 수 있는 보안과 관련된 고려 사항들(주로 자원 활용, 정보 접근 등)을 확인할 수 있게 되었다.

 안드로이드는 오랜 기간초기 설계 이후로 큰 문제가 발생하지 않았고 구조를 유지해오고 있다는 점에서 아주 잘 설계되었다고 말할 수 있다. 

 안드로이드 진영은 ios진영의 영향을 받아 본인들의 서버에서 앱을 감시하는 방식을 강화하고 있다. (ios는 앱이 자체 규정을 지키고 있는지를 검사함)